# -*- coding: utf-8 -*-
"""qdrant_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nkS3HiMl8xRCTqbgjplr6qo6qpuuYaaz
"""

pip install qdrant-client

from qdrant_client import QdrantClient
client = QdrantClient(host="localhost", port=6333)

print('HTTP', requests.get("http://localhost:6333/healthz").text)

import requests
r = requests.get(
    "http://localhost:6333/healthz",
    proxies={"http": None, "https": None}  # обход всех proxy
)
print(r.text)          # → {"status":"ok"}

from qdrant_client import QdrantClient
client = QdrantClient(url="http://localhost:6333")
print(client.get_collections())

from qdrant_client.http import models as rest
# Размерность вектора (size) - задается один раз и ее нельзя менять
client.recreate_collection(
    collection_name="articles",
    vectors_config=rest.VectorParams(size=384, distance=rest.Distance.COSINE)
)

"""Поэтому во многих базах данных (Qdrant, Weaviate и др.) при создании коллекции с метрикой Cosine векторы автоматически нормализуются при сохранении.
HNSW-индекс: идет снизу вверх и тщательно перебирает все значения.
Во время поиска алгоритм идёт жадно: на каждом шаге переходит к соседу, чей вектор ближе к запросу. Если дальше улучшений нет — спускается уровнем ниже, пока не дойдёт до самого подробного слоя.

## **Qdrant (“Quadrant”)** — это специализированная база данных для работы с векторными представлениями (vector embeddings). Коротко: она хранит и быстро ищет объекты, описанные не привычными строками/числами, а много-мерными векторами.
"""

from sentence_transformers import SentenceTransformer
import numpy as np
#query -> применяем к ним vector
sentences = [
    "Кот играет на ковре",      # id = 0
    "Собака тихо спит",         # id = 1
    "Автомобиль быстро едет",   # id = 2
    "Инвестор закупает акции",
    "Котенок играет с клубком",
    "Корова жует траву" # id = 2
]
model = SentenceTransformer("all-MiniLM-L6-v2")

vectors = model.encode(sentences, normalize_embeddings=True)

# Каждая точка = id + vector + payload. Поля из payload можно использовать в фильтрах.
payloads = [                         # любое поле можно фильтровать
    {"tag": "animals",  "year": 2023},
    {"tag": "animals",  "year": 2022},
    {"tag": "vehicles", "year": 2023},
    {"tag": "people",   "year": 2021},
    {"tag": "animals",  "year": 2024},
    {"tag": "animals",  "year": 2023},
]

client.upsert(
    collection_name="articles",
    points=[
        rest.PointStruct(id=i, vector=v.tolist(), payload=payloads[i])
        for i, v in enumerate(vectors)
    ]
)

query_vec = model.encode(
    "котенок жует траву", normalize_embeddings=True
)

hits = client.search(
    collection_name="articles",
    query_vector=query_vec.tolist(),
    limit=4
)

for hit in hits:
    print(f"score={hit.score:.3f}  →  {sentences[hit.id]}")

"""Поиск в Qdrant: базовый k-NN и поиск с фильтрацией"""

#2.1 Базовый поиск (только по вектору)
from qdrant_client import QdrantClient, models

client = QdrantClient(host="localhost", port=6333)

query_vector = [0.12]*384 ## ← эмбеддинг запроса
top_k = 5

hits = client.search(
    collection_name = "articles",
    query_vector=query_vector,
    limit=top_k,
    with_vectors=False,              # в ответ не тащим сами векторы
    with_payload=True                # но хотим метаданные
)

for hit in hits:
    print(f"ID={hit.id:>4}  score={hit.score:.4f}  category={hit.payload.get('category')}")

"""1. should=[…] — OR-условия;
2. must_not=[…] — исключить записи;
3. range, geo_bounding_box, geo_radius — числовые диапазоны и поиск по координатам.
"""

#Поиск с фильтром по payload
from datetime import datetime

flt = models.Filter(
    must=[
        models.FieldCondition(
            key="tag",
            match=models.MatchValue(value="animals")
        ),
        models.FieldCondition(
            key="year",
            range=models.Range(gte=2023)
        )
    ]
)

hits = client.search(
    collection_name="articles",
    query_vector=query_vector,
    limit=top_k,
    query_filter=flt,
    with_payload=True
)

for hit in hits:
    print(f"ID={hit.id:>4}  score={hit.score:.4f}  category={hit.payload.get('tag')}")

hits = client.search(
    collection_name="articles",
    query_vector=query_vector,
    limit=top_k,
    search_params=models.SearchParams(
        hnsw_ef=256,   # ↑ точность, ↓ скорость (обычный диапазон 32‒256)
        exact=False    # False = Approximate Nearest Neighbour (по умолчанию)
    )
)

for hit in hits:
    print(f"ID={hit.id:>4}  score={hit.score:.4f}  category={hit.payload.get('tag')}")

"""## Массовая загрузка данных и базовая статистика коллекции"""

import numpy as np
from qdrant_client import QdrantClient, models

client = QdrantClient("http://localhost:6333")
# Сгенерируем пример данных
N          = 20_000
vectors    = np.random.rand(N, 768).astype(np.float32)          # (N, 768)
categories = np.random.choice(["tech", "finance", "sports"], N)
years      = np.random.randint(2021, 2025, N)

points = [ #client.upload_points автоматически разобьёт массив на батчи.
    models.PointStruct(
        id=i,
        vector=vectors[i],
        payload={
            "category": str(categories[i]),
            "year": int(years[i])
        }
    ) for i in range(N)
]

client.upload_points(
    collection_name="articles",
    points=points,
    batch_size=1000,         # ← задаём желаемый размер пакета
    parallel=4               # ← потоков (CPU-ядра); 0 = авто
)

print("Импорт завершён!")

# Количество точек (быстрый способ) --> точка (point) – это одна запись в векторной базе.
count = client.get_collection("articles").points_count
print(f"Сейчас в коллекции {count:,} точек")

# Дополнительная информация о коллекции
info = client.get_collection("articles")
print("Статус:", info.status)                         # green / yellow / red
print("Статус оптимизатора:", info.optimizer_status)  # ok / in_progress / ...
print("Сегментов:", info.segments_count)              # <- было segments_size (ошибка)
print("Всего векторов:", info.vectors_count)
print("Проиндексировано:", info.indexed_vectors_count)